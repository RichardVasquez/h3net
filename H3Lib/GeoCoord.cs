using System;
using System.Diagnostics;
using H3Lib.Extensions;

namespace H3Lib
{
    /// <summary>
    /// Functions for working with lat/lon coordinates.
    /// </summary>
    [DebuggerDisplay("Lat: {Latitude} Lon: {Longitude}")]
    public readonly struct GeoCoord:IEquatable<GeoCoord>
    {
        public readonly double Latitude;
        public readonly double Longitude;

        public GeoCoord(double latitude, double longitude)
        {
            Latitude = latitude;
            Longitude = longitude;
        }

        public GeoCoord(GeoCoord gc)
        {
            Latitude = gc.Latitude;
            Longitude = gc.Longitude;
        }

        public override string ToString()
        {
            return $"GeoCoord: (Lat,Lng) {Latitude:F9}, {Longitude:F9}";
        }

        /*
         * The following functions provide meta information about the H3 hexagons at
         * each zoom level. Since there are only 16 total levels, these are current
         * handled with hardwired static values, but it may be worthwhile to put these
         * static values into another file that can be autogenerated by source code in
         * the future.
         */
        
        // geoCoord.c double H3_EXPORT(hexAreaKm2)
        public static double HexAreaKm2(int res)
        {
            return Constants.GeoCoord.AreasKm2[res];
        }

        // geoCoord.c double H3_EXPORT(hexAreaM2)
        public static double HexAreaM2(int res)
        {
            return Constants.GeoCoord.AreasM2[res];
        }

        // geoCoord.c double H3_EXPORT(edgeLengthKm)
        public static double EdgeLengthKm(int res)
        {
            return Constants.GeoCoord.EdgeLengthKm[res];
        }

        // geoCoord.c double H3_EXPORT(edgeLengthM)
        public static double EdgeLengthM(int res)
        {
            return Constants.GeoCoord.EdgeLengthM[res];
        }

        /// <summary>
        /// Surface area in radians^2 of spherical triangle on unit sphere.
        ///
        /// For the math, see:
        /// https://en.wikipedia.org/wiki/Spherical_trigonometry#Area_and_spherical_excess
        /// </summary>
        /// <param name="a">length of triangle side A in radians</param>
        /// <param name="b">length of triangle side B in radians</param>
        /// <param name="c">length of triangle side C in radians</param>
        /// <returns>area in radians^2 of triangle on unit sphere</returns>
        /// <!--
        /// geoCoord.c
        /// double triangleEdgeLengthsToArea
        /// -->
        private static double TriangleEdgeLengthToArea(double a, double b, double c)
        {
            double s = (a + b + c) / 2;

            a = (s - a) / 2;
            b = (s - b) / 2;
            c = (s - c) / 2;
            s /= 2;

            return 4 * Math.Atan
                       (Math.Sqrt(Math.Tan(s) *
                                  Math.Tan(a) * 
                                  Math.Tan(b) *
                                  Math.Tan(c)));
        }

        /// <summary>
        /// Compute area in radians^2 of a spherical triangle, given its vertices.
        /// </summary>
        /// <param name="a">vertex lat/lng in radians</param>
        /// <param name="b">vertex lat/lng in radians</param>
        /// <param name="c">vertex lat/lng in radians</param>
        /// <returns>area of triangle on unit sphere, in radians^2</returns>
        /// <!--
        /// geoCoord.c
        /// double triangleArea
        /// -->
        public static double TriangleArea(GeoCoord a, GeoCoord b, GeoCoord c)
        {
            return TriangleEdgeLengthToArea
                (a.DistanceToRadians(b),
                 b.DistanceToRadians(c),
                 c.DistanceToRadians(a));
        }

        public bool Equals(GeoCoord  other, double epsilon)
        {
            return
                Math.Abs(Latitude - other.Longitude) < epsilon &&
                Math.Abs(Longitude - other.Longitude) < epsilon;
        }

        
        public bool Equals(GeoCoord other)
        {
            return
                Math.Abs(Latitude - other.Latitude) < Constants.H3.EPSILON_RAD &&
                Math.Abs(Longitude - other.Longitude) < Constants.H3.EPSILON_RAD;
        }

        public override bool Equals(object obj)
        {
            return obj is GeoCoord other && Equals(other);
        }

        public override int GetHashCode()
        {
            return HashCode.Combine(Latitude, Longitude);
        }

        public static bool operator ==(GeoCoord left, GeoCoord right)
        {
            return left.Equals(right);
        }

        public static bool operator !=(GeoCoord left, GeoCoord right)
        {
            return !left.Equals(right);
        }
    }
}
